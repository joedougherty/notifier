#!/usr/bin/env python
# -*- coding: utf-8 -*-
import serial, serial.tools.list_ports
import subprocess
import logging
import time
import importlib
import os
import sys
import argparse
try:
    import ConfigParser as configparser
except:
    # Python 3  
    import configparser

def createlogger(logfile_location=None):
    logger = logging.getLogger()

    if logfile_location is None:
        handler = logging.StreamHandler()
    else:
        handler = logging.FileHandler(logfile_location)

    formatter = logging.Formatter('[%(asctime)s] %(levelname)-8s %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.DEBUG)
    return logger

def alert(title="Pay Attention!", msg="Someone wants to speak with you."):
    if use_default_alert():
        rc = subprocess.call(["/usr/bin/notify-send", title, msg])
        if rc == 0:
            log.info('/usr/bin/notify received return code 0')
        else:
            log.error('/usr/bin/notify received return code {}'.format(rc))

def identify_board(p):
    if p.description == 'Adafruit' and p.manufacturer == 'Flora':
        return True
    return False

def autoconnect(alert_user_on_connection=False):
    log.info('Attempting to find + connect to USB device...')

    device_not_found = True

    while device_not_found:
        known_ports = list(serial.tools.list_ports.comports())
        for p in known_ports:
            if identify_board(p):
                log.info('Found device at address: {}'.format(p.device))
                device_not_found = False
        time.sleep(1)

    if alert_user_on_connection:
        alert(msg="USB connected! :]")

    return serial.Serial(p.device, 9600, timeout=10)

def run_action_a(usermodule=None):
    if usermodule is None: 
        return

    try:
        usermodule.run_action_a()
    except:
        log.error('There was an error trying to run action A.')

def run_action_b(usermodule=None):
    if usermodule is None:
        return

    try:
        usermodule.run_action_b()
    except Exception as e:
        log.error('There was an error trying to run action B.')
        log.error(e)

def run_action_c(usermodule=None):
    if usermodule is None:
        return

    try:
        usermodule.run_action_c()
    except:
        log.error('There was an error trying to run action C.')

def run_action_d(usermodule=None):
    if usermodule is None:
        return

    try:
        usermodule.run_action_d()
    except:
        log.error('There was an error trying to run action D.')

def on_connect(usermodule=None):
    if usermodule is None:
        return

    try:
        usermodule.on_connect()
    except:
        pass

def on_disconnect(usermodule=None):
    if usermodule is None:
        return 

    try:
        usermodule.on_disconnect()
    except:
        pass

def use_default_alert():
    """ 
    Use the default alert unless the user specifies otherwise
    explicitly in the config file.
    """
    try:
        return config_file().getboolean('notifier', 'use_default_alert')
    except:
        return True

def customcode():
    if config_file():
        try:
            path_to_custom_events = config_file().get('notifier', 'custom_script')
            log.info('Looking for custom script file at {}...'.format(path_to_custom_events))
        except configparser.NoOptionError:
            log.info('custom_script variable not set in config file.') 
            return False

        if not os.path.exists(path_to_custom_events):
            log.error("Could not find a file named {}.".format(path_to_custom_events))
            raise IOError

        containing_dir = os.path.split(path_to_custom_events)[0]
        sys.path.append(containing_dir) 
        return importlib.import_module('notifieractions')
    return False 

def config_file():
    config_location = os.path.join(os.path.expanduser('~'), '.notifier.conf')
    if not os.path.exists(config_location):
        log.info('No config file found at {}.'.format(config_location))
        return False

    try:
        cfg = configparser.ConfigParser()
        cfg.read(config_location)
        return cfg
    except:
        log.error('Config file at {} could not be read.'.format(config_location))
        return False

def main(port=None):
    while True:
        try:
            serialMsg = port.readline().strip()
        except serial.serialutil.SerialException:
            log.error('USB disconnected.')
            alert(msg="USB disconnected. :[")
            on_disconnect(usermodule=usermodule)

            port = autoconnect(alert_user_on_connection=True)
            on_connect(usermodule=usermodule)

            serialMsg = port.readline().strip()

        if serialMsg in ('a_recvd', b'a_recvd'): # A Button
            log.info('Received {} from serial.'.format(serialMsg.strip()))
            run_action_a(usermodule=usermodule)

        if serialMsg in ('b_recvd', b'b_recvd'): # B Button
            log.info('Received {} from serial.'.format(serialMsg.strip()))
            run_action_b(usermodule=usermodule)

        if serialMsg in ('c_recvd', b'c_recvd'): # C Button
            log.info('Received {} from serial.'.format(serialMsg.strip()))
            run_action_c(usermodule=usermodule)

        if serialMsg in ('d_recvd', b'd_recvd'): # D Button
            log.info('Received {} from serial.'.format(serialMsg.strip()))
            alert()
            run_action_d(usermodule=usermodule)

if __name__ == '__main__':
    desc = "The Distractinator(TM) notifier!"
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('--log', help='Absolute path to the desired log. (/path/to/file.log)', type=str, required=False)
    args = parser.parse_args()

    log = createlogger(args.log)
    log.info('notifier started.')

    # Let's go find your custom actions file
    try:
        usermodule = customcode()
    except IOError:
        sys.exit(2)

    p = autoconnect() # Won't you join me on the perennial quest?
    on_connect(usermodule=usermodule)

    main(port=p)
